---
title: React Native environment variables
date: 2023-03-23
tags: devops, react, react-native, fullstack
description: How to set up a React Native project such that you get your env vars where ever you're coding.
---

# Set up environment variables in React Native to optimize for sensible productivity

Let me pose to you this question: whether or not you're actively working on native code, would you want to have your environment variables available on both the javascript _and_ native sides of the code? I would. That's what I did, and this is about how I've done it. 

## Set up the common side
1. Install `react-native-config`. There are other options. I like this one.

## Set up iOS (mostly XCode)

Add a new configuration file. Name it whatever you'd like, but add this at the end: `#include? "tmp.xcconfig"`. This will cause XCode to include any environment variables that are present in the `tmp.xcconfig` file that is generated by `react-native-config`.

Create a Scheme for each built variant (ie. environment variable file) you want _except_ for production. You can use the existing scheme for that since it can't be renamed. I have `development` and `staging`. Once they're created, add some pre-build scripts that will copy the env file you want associated with that particular scheme to the global ENV file that `react-native-config` uses to provide variables to the React Native bridge.

(Screenshot of the 'Manage Schemes' interface in XCode)

Here are the scripts I use:

``` shell
rm "${CONFIGURATION_BUILD_DIR}/${INFOPLIST_PATH}"
echo ".env.production" > /tmp/envfile
```
This one does the copying.

``` shell
"${SRCROOT}/../node_modules/react-native-config/ios/ReactNativeConfig/BuildXCConfig.rb" "${SRCROOT}/.." "${SRCROOT}/tmp.xcconfig"
```
This one runs the `react-native-config` XCode-specific build commands to ensure those fancy variables are available to all your XCode-related dreams.

Do this for each Scheme, replacing `.env.production` with the full name of the environment variable file you have in your React Native client root folder (the one that's a level above your ios/ and android/ folders). *Be sure* that the "Provide build settings from" setting is set to your project (and not the autogenerated test project or nothing at all). It's also important to ensure that the scripts are listed in XCode in the same order you see them above. The second script relies on what the first accomplishes.

You'll need a way to make sure that your pods have access to this information as well. I did it by modifying the Podfile script directly, as in the following. This script just adds a reference to the config file you created in the first step above. Be sure to change the name of the xcconfig file to whatever you chose to name it before.

``` ruby
  post_install do |installer|
  # ... other installer tasks. Put this right at the end.

    # Set up references to the ENV file we use globally
    debug_path = "Pods/Target Support Files/Pods-micdrp/Pods-micdrp.debug.xcconfig"
    release_path = "Pods/Target Support Files/Pods-micdrp/Pods-micdrp.release.xcconfig"
    debug_tests_path = "Pods/Target Support Files/Pods-micdrp-micdrpTests/Pods-micdrp-micdrpTests.debug.xcconfig"
    release_tests_path = "Pods/Target Support Files/Pods-micdrp-micdrpTests/Pods-micdrp-micdrpTests.release.xcconfig"
    
    File.open(debug_path, 'a') do |file|
      file.puts "\n#include? \"../../../env.xcconfig\""
    end

    File.open(release_path, 'a') do |file|
      file.puts "\n#include? \"../../../env.xcconfig\""
    end

    File.open(debug_tests_path, 'a') do |file|
      file.puts "\n#include? \"../../../env.xcconfig\""
    end

    File.open(release_tests_path, 'a') do |file|
      file.puts "\n#include? \"../../../env.xcconfig\""
    end
```

After all this, for good measure, I'd run a `pod cache clean --all && pod install` from your `ios` directory.

### BONUS!

If you've already done the steps [here](https://ryer.io/learning/align-xcode-version-numbers)


## Set up Android (mostly Android Studio)

Open Android Studio, along with the `/android` folder within your React Native project. Open up the `build.gradle` file associated with your app's module (not the project-level one). You'll want to set up your environment file references and point `react-native-config` to its own `dotenv.gradle`.

Here's what I put just below `apply plugin: "com.android.application"`:

``` groovy
// Callable using the --variant command switch when running react-native run-android
// Example: react-native run-android --variant staging
project.ext.envConfigFiles = [
  debug: ".env.development", // This will become the original "Debug" mode
  staging: ".env.staging", // We are replacing the default functionality for the Debug variant here
  release: ".env.production",
]

apply from: project(':react-native-config').projectDir.getPath() + "/dotenv.gradle"

// ... all the rest of your config
```

Before we add any more, I'll explain why we're using "debug" and "release". Essentially, while it's possible to use different names here, it's hard because the React Native build system generates gradle tasks with the names `debug` and `release` in them--they're hard-coded in the RN build scripts. We're going to intercept this at the lowest possible point that we still have control over in a sensible way. That's what the `project.ext.envConfigFiles` does. When you modify your `package.json`'s run scripts, make sure to use `--variant debug` and `--variant release` instead of `development` and `production`.

Next add some reasonable bundling behaviour in the react config:

``` groovy
project.ext.react = {
  bundleInDebug: false,
  bundleInStaging: true,
  bundleInRelease: true,
  jsBundleDirDebug: "$buildDir/intermediates/assets/debug",
  resourcesDirDebug: "$buildDir/intermediates/res/merged/debug",
  jsBundleDirStaging: "$buildDir/intermediates/assets/staging",
  resourcesDirStaging: "$buildDir/intermediates/res/merged/staging",
  jsBundleDirRelease: "$buildDir/intermediates/assets/release",
  resourcesDirRelease: "$buildDir/intermediates/res/merged/release",
  devDisabledInDebug: false,
  devDisabledInStaging: true,
  devDisabledInRelease: true,
  debuggableVariants: ["debug", "staging"],
  inputExcludes: ["ios/**", "__tests__/**", "ota/**"],
  enableHermes: false,  // clean and rebuild if changing
}
```

This makes sure we don't bundle anything in development (debug), but allows both staging and development to attach to a debugger. The `inputExcludes` property provides a way to exclude folders from being searched for bundle-related files.

Next up--and especially if you've opted to [keep your iOS version numbers aligned](https://ryer.io/learning/align-xcode-version-numbers.html) and want to eventually [automate your versioning system](https://ryer.io/learning/automate-your-version-numbers.html)--let's replace the hard-coded version number and version name with a dynamic one that comes from your centralized ENV files. Find the `android.defaultConfig` set of properties, and modify these:

``` groovy
versionCode project.env.get("BUILD_NUMBER").toInteger()
versionName project.env.get("VERSION_NUMBER")
resValue "string", "build_config_package", "${applicationId}"
```

And finally, you'll need to add your new build variants to the `buildTypes` section of the file:

``` groovy 
debug {
  debuggable true
  signingConfig signingConfigs.debug
//applicationIdSuffix ".development"
}
staging {
  debuggable true
  matchingFallbacks = ['release']
  signingConfig signingConfigs.release
//applicationIdSuffix ".staging"
  minifyEnabled enableProguardInReleaseBuilds
  proguardFiles getDefaultProguardFile("proguard-android.txt"), "proguard-rules.pro"
}
release {
  // Caution! In production, you need to generate your own keystore file.
  // see https://reactnative.dev/docs/signed-apk-android.
  signingConfig signingConfigs.release
  minifyEnabled enableProguardInReleaseBuilds
  proguardFiles getDefaultProguardFile("proguard-android.txt"), "proguard-rules.pro"
}
```

I wasn't able to get the `applicationIdSuffix` to work as intended in the time I had to configure this, so I left it out. It allows you to install all three apps onto a physical or simulated device at the same time (since they won't occupy the same namespace).